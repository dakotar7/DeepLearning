
import torch
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
import matplotlib.pyplot as plt
import numpy as np
import pickle as pkl

# CelebADataLoader Class
class CelebADataLoader:
    def __init__(self, batch_size, image_size, data_dir='processed_celeba_small/'):
        self.batch_size = batch_size
        self.image_size = image_size
        self.data_dir = data_dir

    def get_dataloader(self):
        # Creates and returns the DataLoader with transformations.
        transform = transforms.Compose([
            transforms.Resize(self.image_size),
            transforms.ToTensor()
        ])
        dataset = datasets.ImageFolder(self.data_dir, transform)
        loader = DataLoader(dataset=dataset, batch_size=self.batch_size, shuffle=True)
        return loader

# Visualizer Class
class Visualizer:
    @staticmethod
    def imshow(img):
        # Display an image.
        npimg = img.numpy()
        plt.imshow(np.transpose(npimg, (1, 2, 0)))
        plt.show()

    @staticmethod
    def view_samples(epoch, samples):
        # View samples generated by the GAN.
        fig, axes = plt.subplots(figsize=(16, 4), nrows=2, ncols=8, sharey=True, sharex=True)
        for ax, img in zip(axes.flatten(), samples[epoch]):
            img = img.detach().cpu().numpy()
            img = np.transpose(img, (1, 2, 0))
            img = ((img + 1) * 255 / 2).astype(np.uint8)
            ax.xaxis.set_visible(False)
            ax.yaxis.set_visible(False)
            ax.imshow(img.reshape((32, 32, 3)))

# GANModel Class
class GANModel:
    def __init__(self, generator, discriminator):
        self.generator = generator
        self.discriminator = discriminator
    
    def forward(self, z):
        return self.generator(z)

    def discriminate(self, img):
        return self.discriminator(img)

# Trainer Class
class Trainer:
    def __init__(self, model, dataloader, epochs=100):
        self.model = model
        self.dataloader = dataloader
        self.epochs = epochs
        self.losses = []

    def train(self):
        # Train the GAN model.
        for epoch in range(self.epochs):
            epoch_losses = []  # For tracking loss per epoch
            for real_images, _ in self.dataloader:
                # Training logic would go here

                # Calculate and store losses (placeholders)
                d_loss = torch.tensor(0.1)  # Example loss
                g_loss = torch.tensor(0.1)  # Example loss
                epoch_losses.append((d_loss.item(), g_loss.item()))
            
            # Append average losses for this epoch
            self.losses.append(np.mean(epoch_losses, axis=0))
        
        return self.losses

# Main program to tie everything together
def main():
    # Step 1: Set up data loading
    batch_size = 100
    img_size = 32
    dataloader = CelebADataLoader(batch_size, img_size).get_dataloader()

    # Step 2: Initialize the GAN model
    # These models would be defined elsewhere
    generator = None  # Placeholder
    discriminator = None  # Placeholder
    model = GANModel(generator, discriminator)

    # Step 3: Train the GAN
    trainer = Trainer(model, dataloader, epochs=100)
    losses = trainer.train()

    # Step 4: Visualize the results (losses visualization as placeholder)
    Visualizer().plot_losses(losses)

if __name__ == '__main__':
    main()
